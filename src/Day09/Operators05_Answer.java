package Day09;


//---- 비트 연산자 ----
// 10진수가 아닌 2진수의 각 비트별로 연산을 진행
// &(비트 AND 연산): 대응되는 비트가 모두 1이면 1을 반환
// |(비트  OR 연산): 대응되는 비트 중 하나라도 1이면 1을 반환
// ^(비트 XOR 연산): 대응되는 비트가 서로 다르면 1을 반환
// ~(비트 NOT 연산): 비트가 0이면 1, 1이면 0으로 반전
// <<(Left Shift 연산): 비트들을 모두 지정 수 만큼 왼쪽으로 이동
// >>(Right Shift 연산): 비트들을 모두 지정 수 만큼 오른쪽으로 이동

//0101 0011 = 83
//&
//0100 0111 = 71
//----------------
//0100 0011 = 67
//
//0101 0011 = 83
//|
//0100 0111 = 71
//----------------
//0101 0111 = 87
//
//0101 0011 = 83
//^
//0100 0111 = 71
//----------------
//0001 0100 = 20
//
//0100 0111 = 71
//<< 1
//----------------
//1000 1110 = 142
//
//0101 0011 = 83
//>> 1
//----------------
//0010 1001 = 41

public class Operators05_Answer {
	public static void main(String[] args)
	{
		/*System.out.println("비트 AND 연산 결과: " + (83 & 71));
		System.out.println("비트  OR 연산 결과: " + (83 | 71));
		System.out.println("비트 XOR 연산 결과: " + (83 ^ 71));
		System.out.println("Left Shift 연산 결과: " + (71 << 1));
		System.out.println("Right Shift 연산 결과: " + (83 >> 1));*/
		
		byte num1 = 78, num2 = 37, num3 = 18;
		byte num4 = 4, num5 = 106;
		
		// 0100 1110 = 78
		// 0010 0101 = 37
		// 0001 0010 = 18
		// 0000 0100 = 4
		// 0110 1010 = 106
		
		System.out.println(num1 | num3);
		// 0100 1110 = 78
		// 0001 0010 = 18
		// 0101 1110 = 94
		System.out.println(num5 & num2);
		// 0110 1010 = 106
		// 0010 0101 = 37
		// 0010 0000 = 32
		System.out.println(num4 ^ num3);
		// 0000 0100 = 4
		// 0001 0010 = 18
		// 0001 0110 = 22
		System.out.println(~num4);
		// 0000 0100 = 4
		// 1111 1011 = -5
		System.out.println(num4 << 3);
		// 0000 0100 = 4
		// 0010 0000 = 32
		System.out.println(num3 >> 1);
		// 0001 0010 = 18
		// 0000 1001 = 9
	}
}





